<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhf的博客</title>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://zzhf.github.com/"/>
  <updated>2017-12-16T17:50:16.132Z</updated>
  <id>https://zzhf.github.com/</id>
  
  <author>
    <name>zhf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>批处理常用命令总结</title>
    <link href="https://zzhf.github.com/2017/12/16/%E6%89%B9%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>https://zzhf.github.com/2017/12/16/批处理常用命令总结/</id>
    <published>2017-12-16T09:29:38.000Z</published>
    <updated>2017-12-16T17:50:16.132Z</updated>
    
    <content type="html"><![CDATA[<p>在研究ELK的过程中发现elastic和logstash必须依赖1.8以上版本的jdk，但是公司的项目主要是依赖于1.7版本的jdk，更要命的是项目所使用的ESB解决方案（<code>Mule ESB</code>）只支持1.6和1.7的特定版本。经过百度一番之后发现可以修改<code>elastic</code>和<code>logstash</code>的<code>bat</code>文件来显式指定<code>jdk</code>来解决程序依赖全局<code>JAVA_HOME</code>的问题</p>
<a id="more"></a>
<h1 id="什么是批处理命令"><a href="#什么是批处理命令" class="headerlink" title="什么是批处理命令"></a>什么是批处理命令</h1><p>批处理是一种简化的脚本语言，是由DOS或者windows系统内嵌的命令解释器（COMMAND.COM/CMD.EXE）解释运行。类型与<code>shell</code>脚本</p>
<h1 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h1><ul>
<li><code>echo</code> 显示消息，或将命令回显打开或关闭</li>
<li><code>rem</code> 注释代码（可回显）</li>
<li><code>pause</code> 暂停批处理文件的处理并显示消息</li>
<li><code>call</code> 从另一个批处理程序调用这个</li>
<li><code>start</code> 启动单独的窗口以运行指定的程序或命令</li>
<li><code>goto</code>与<code>label</code> 命令跳转 </li>
<li><code>set</code> 设置变量</li>
</ul>
<p>更多详情可在windows命令窗口输入HELP来查看详情</p>
<h1 id="常用的符号"><a href="#常用的符号" class="headerlink" title="常用的符号"></a>常用的符号</h1><h4 id="符号"><a href="#符号" class="headerlink" title="@符号"></a><code>@</code>符号</h4><p>屏蔽当前行的回显</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@echo off</div></pre></td></tr></table></figure>
<p>这行命令表示不在控制台显示<code>echo off</code>命令， 同时<code>echo off</code>又可以关闭后续命令的回显，因此这是大部分批处理文件的通用起始代码。</p>
<h4 id="重定向符号（输出）"><a href="#重定向符号（输出）" class="headerlink" title="重定向符号（输出）"></a>重定向符号（输出）</h4><p>将输出信息重定向至指定的设备或文件。系统默认输出到显示器<br>重定向符号有<code>&gt;</code>,<code>&gt;&gt;</code>两种</p>
<p><code>&gt;</code> 符号会覆盖目标的原有内容<br><code>&gt;&gt;</code> 符号则是在目标内容的结尾追加</p>
<h4 id="重定向符号（输入）"><a href="#重定向符号（输入）" class="headerlink" title="重定向符号（输入）"></a>重定向符号（输入）</h4><p>将输入信息来源重定向为指定的设备或文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line"></div><div class="line">echo 拖动txt文件至窗口查看文件名称</div><div class="line">set /p content=</div><div class="line">echo %content%</div><div class="line">pause</div></pre></td></tr></table></figure>
<h4 id="管道符号"><a href="#管道符号" class="headerlink" title="管道符号 |"></a>管道符号 <code>|</code></h4><p>将管道符号前面的命令的输出结果输出到管道符号后面的命令中去，作为下一个命令的输入</p>
<h4 id="转义符号"><a href="#转义符号" class="headerlink" title="转义符号"></a>转义符号</h4><p>将特殊符号转化为一般符号 特殊符号指： <code>|</code> <code>&amp;</code> <code>&gt;</code> <code>&lt;</code></p>
<h4 id="逻辑命令-amp-amp-amp"><a href="#逻辑命令-amp-amp-amp" class="headerlink" title="逻辑命令 &amp; &amp;&amp; ||"></a>逻辑命令 <code>&amp;</code> <code>&amp;&amp;</code> <code>||</code></h4><p><code>&amp;</code> 连接多个DOS命令，并把这些命令按顺序执行，而不管是否有命令执行失败；<br><code>&amp;&amp;</code> 当前面的命令成功执行才会执行后面的命令，否则不执行（起到短路的效果）<br><code>||</code> 当前面的命令执行失败时才会执行后面的命令，否则不执行</p>
<h1 id="语句结构"><a href="#语句结构" class="headerlink" title="语句结构"></a>语句结构</h1><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><p>if语句实现条件判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set /p choice=是否显示当前时间？ （y/n）</div><div class="line">if /i not %choice% EQU n echo 当前时间是： %date% %time%</div></pre></td></tr></table></figure></p>
<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p>for语句可以实现类似于C语言里面的循环结构，当然for语句的功能要更强大一点，通过不同的开关可以实现更多的功能。for语句有多个开关，不同开关将会实现不同的功能。</p>
<ol>
<li>无开关<br>无开关的for语句能够对设定的范围内进行循环，其命令格式为<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FOR %%variable IN (set) DO command</div></pre></td></tr></table></figure>
</li>
</ol>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line">for %%i in (a,&quot;b c&quot;,d) do echo %%i</div></pre></td></tr></table></figure></p>
<ol>
<li>含开关<code>/L</code><br>含开关/L的for语句，可以根据set里面的设置进行循环，从而实现对循环次数的直接控制。其命令格式为：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FOR /L %%variable IN (start, step, end) DO command</div></pre></td></tr></table></figure>
<p>其中，start为开始计数的初始值，step为每次递增的值，end为结束值。当end小于start时，step需要设置为负数。</p>
<p>示例: 新建5个文件夹，文件夹名称依次为1,3,5,7,9<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line">for /l %%i in (1, 2, 10) do md %%i</div><div class="line">pause</div></pre></td></tr></table></figure></p>
<ol>
<li>含开关<code>/F</code><br>含开关<code>/F</code>的<code>for</code>语句具有最强大的功能，它能够对字符串进行操作，也能够对命令的返回值进行操作，还可以访问硬盘上的<code>ASCII</code>码文件，比如<code>txt</code>文档等。其命令格式为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line">FOR /F [&quot;options&quot;] %%variable IN (set) DO command</div></pre></td></tr></table></figure>
</li>
</ol>
<p>其中set为（”string”, “commond”, “file-set”）中的一个</p>
<h1 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h1><ol>
<li>SystemDrive 当前启动的系统所在的分区</li>
<li>SystemRoot 当前系统所在的目录</li>
<li>windir 当前启动的系统所在的目录</li>
<li>userprofile 当前用户数据变量</li>
<li>cd 当前的目录</li>
<li>computername 返回计算机名称</li>
<li>username 返回当前登录的用户的名称</li>
<li>date 返回当前日期</li>
<li>time 返回当前时间</li>
<li>os 返回操作系统名称</li>
<li><p>path 可执行文件的搜索路径</p>
</li>
<li><p>JAVA_HOME （配置的全局变量）</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在研究ELK的过程中发现elastic和logstash必须依赖1.8以上版本的jdk，但是公司的项目主要是依赖于1.7版本的jdk，更要命的是项目所使用的ESB解决方案（&lt;code&gt;Mule ESB&lt;/code&gt;）只支持1.6和1.7的特定版本。经过百度一番之后发现可以修改&lt;code&gt;elastic&lt;/code&gt;和&lt;code&gt;logstash&lt;/code&gt;的&lt;code&gt;bat&lt;/code&gt;文件来显式指定&lt;code&gt;jdk&lt;/code&gt;来解决程序依赖全局&lt;code&gt;JAVA_HOME&lt;/code&gt;的问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="批处理 Batch" scheme="https://zzhf.github.com/tags/%E6%89%B9%E5%A4%84%E7%90%86-Batch/"/>
    
  </entry>
  
  <entry>
    <title>Vuex之State</title>
    <link href="https://zzhf.github.com/2017/12/04/Vuex%E4%B9%8BState/"/>
    <id>https://zzhf.github.com/2017/12/04/Vuex之State/</id>
    <published>2017-12-04T14:39:45.000Z</published>
    <updated>2017-12-04T16:15:58.403Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex是一个专门为Vue程序开发的状态管理模式。</p>
<a id="more"></a>
<p><code>store</code>是Vuex的一个核心，你的应用的状态可通过Vuex在<code>store</code>中管理。但是与普通的对象又有区别，区别主要有以下两点：</p>
<ol>
<li><p>Vuex的状态存储是响应式的。当组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件亦会得到通知，这可以与<br><code>computed</code>很好的结合起来使用;</p>
</li>
<li><p>你不能直接改变store中的状态。改变store中的状态的唯一途径就是显式地提交（commit）mutation（通过action间接的提交mutation）。</p>
</li>
</ol>
<h4 id="最简单的Store"><a href="#最简单的Store" class="headerlink" title="最简单的Store"></a>最简单的<code>Store</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果在模块化构建系统中，请确保在开头调用Vue.use(Vuex)</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</div><div class="line">    state: &#123;</div><div class="line">        count: <span class="number">0</span></div><div class="line">    &#125;,</div><div class="line">    mutations: &#123;</div><div class="line">        increment (state) &#123;</div><div class="line">            state.count ++</div><div class="line">        &#125;        </div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//通过调用increment来实现state中count的状态变更</span></div><div class="line">store.commit(<span class="string">'increment'</span>);</div><div class="line"></div><div class="line"><span class="comment">//获取state</span></div><div class="line"><span class="built_in">console</span>.log(store.state.count)</div></pre></td></tr></table></figure>
<h4 id="实现Vue组件获取Vuex状态的方式"><a href="#实现Vue组件获取Vuex状态的方式" class="headerlink" title="实现Vue组件获取Vuex状态的方式"></a>实现Vue组件获取Vuex状态的方式</h4><h5 id="1-直接访问store"><a href="#1-直接访问store" class="headerlink" title="1. 直接访问store"></a>1. 直接访问store</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//模块化构建系统需引入store</span></div><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="comment">//创建一个Count组件</span></div><div class="line"><span class="keyword">const</span> Counter = &#123;</div><div class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</div><div class="line">    computed: &#123;</div><div class="line">        count() &#123;</div><div class="line">            <span class="keyword">return</span> store.state.count</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式存在的问题就是每一个需要使用store的组件都需要导入。</p>
<h5 id="2-通过store选项从根组件注入到所有的子组件"><a href="#2-通过store选项从根组件注入到所有的子组件" class="headerlink" title="2. 通过store选项从根组件注入到所有的子组件"></a>2. 通过store选项从根组件注入到所有的子组件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    el: <span class="string">'#app'</span>,</div><div class="line">    <span class="comment">//把store对象复制给store属性，让所有的子组件共享同一store</span></div><div class="line">    store,</div><div class="line">    components: &#123; Counter &#125;,</div><div class="line">    template: <span class="string">`&lt;div class="app"&gt;</span></div><div class="line"><span class="string">        &lt;counter&gt;&lt;/counter&gt;</span></div><div class="line"><span class="string">    &lt;/div&gt;`</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//counter的实现</span></div><div class="line"><span class="comment">//创建一个Count组件</span></div><div class="line"><span class="keyword">const</span> Counter = &#123;</div><div class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</div><div class="line">    computed: &#123;</div><div class="line">        count() &#123;</div><div class="line">            <span class="comment">//注意例一的实现为 return store.state.count </span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$state.state.count</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-通过mapState函数为组件生成计算属性"><a href="#3-通过mapState函数为组件生成计算属性" class="headerlink" title="3. 通过mapState函数为组件生成计算属性"></a>3. 通过mapState函数为组件生成计算属性</h5><p>当一个组件需要从state获取多个状态的时候，将一个个状态赋值到计算属性中未免显得有些繁琐，Vuex为我们提供了mapState辅助函数来帮助我们赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//从vuex中获取mapState辅助函数</span></div><div class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line">    </div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    computed: mapState(&#123;</div><div class="line">        <span class="comment">//将state的count赋值给计算属性myCount</span></div><div class="line">        myCount: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</div><div class="line">        </div><div class="line">        <span class="comment">//传字符串参数等于获取state.count</span></div><div class="line">        countAlias: <span class="string">'count'</span>,</div><div class="line">        </div><div class="line">        <span class="comment">//如果state中属性名与计算属性同名，可以使用简写。等效于 count: 'count'</span></div><div class="line">        <span class="string">'count'</span></div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-通过对象展开运算符混合组件本身的计算属性和mapSate"><a href="#4-通过对象展开运算符混合组件本身的计算属性和mapSate" class="headerlink" title="4. 通过对象展开运算符混合组件本身的计算属性和mapSate"></a>4. 通过对象展开运算符混合组件本身的计算属性和mapSate</h5><p>如果组件有自身的计算属性，怎么实现mapState与自身的计算属性混合呢？为避免手动合并两个对象，我们可以通过对象展开运算符来简化我们的写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">    localComputed () &#123;<span class="comment">/** **/</span>&#125;,</div><div class="line"></div><div class="line">    <span class="comment">//通过对象展开运算符将mapState返回的对象混入到localComputed对象中</span></div><div class="line">    ...mapState(&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vuex是一个专门为Vue程序开发的状态管理模式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于ELK搭建日志监控平台</title>
    <link href="https://zzhf.github.com/2017/11/29/%E5%9F%BA%E4%BA%8EELK%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/"/>
    <id>https://zzhf.github.com/2017/11/29/基于ELK搭建日志监控平台/</id>
    <published>2017-11-29T15:18:44.000Z</published>
    <updated>2017-11-29T15:24:52.742Z</updated>
    
    <content type="html"><![CDATA[<p>公司产品一直没有个真正的日志监控系统，现在的日志系统的是通过实现<code>javax.servlet.Filter</code>来实现访问的监控，这种方式在使用过程遇到了非常多的问题，比如性能低、监控遗漏等问题。听闻ELK是一个广泛采用的日志监控解决方案，所以尝试在一个新项目中使用<code>ELK</code>搭建一个系统日志监控平台。</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司产品一直没有个真正的日志监控系统，现在的日志系统的是通过实现&lt;code&gt;javax.servlet.Filter&lt;/code&gt;来实现访问的监控，这种方式在使用过程遇到了非常多的问题，比如性能低、监控遗漏等问题。听闻ELK是一个广泛采用的日志监控解决方案，所以尝试在一个新项目中使用&lt;code&gt;ELK&lt;/code&gt;搭建一个系统日志监控平台。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ELK Tomcat" scheme="https://zzhf.github.com/tags/ELK-Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>leaflet util</title>
    <link href="https://zzhf.github.com/2017/11/17/leaf-util/"/>
    <id>https://zzhf.github.com/2017/11/17/leaf-util/</id>
    <published>2017-11-17T15:43:39.000Z</published>
    <updated>2017-11-17T16:06:59.298Z</updated>
    
    <content type="html"><![CDATA[<h4 id="extend函数"><a href="#extend函数" class="headerlink" title="extend函数"></a>extend函数</h4><p>合并函数，实现将第一个参数之后的所有对象合并至第一个参数对象中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// @function extend(dest: Object, src?: Object): Object</span></div><div class="line"><span class="comment">// Merges the properties of the `src` object (or multiple objects)</span></div><div class="line"><span class="comment">// into `dest` object and returns the latter. Has an `L.extend` shortcut.</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">dest</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i, j, len, src;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; j &lt; len; j++) &#123;</div><div class="line">        src = <span class="built_in">arguments</span>[j];</div><div class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> src) &#123;</div><div class="line">            dest[i] = src[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="creat函数"><a href="#creat函数" class="headerlink" title="creat函数"></a>creat函数</h4><p><code>creat</code>函数为<code>Object.create</code>函数的<code>polyfill</code>, 创建一个新的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @function create(proto: Object, properties?: Object): Object</span></div><div class="line"><span class="comment">// Compatibility polyfill for [Object.create]</span></div><div class="line"><span class="comment">// (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)</span></div><div class="line"><span class="keyword">var</span> create = <span class="built_in">Object</span>.create || (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">proto</span>) </span>&#123;</div><div class="line">        F.prototype = proto;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h4 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h4><p><code>bind</code>函数用于绑定函数上下文，类似与<code>Function.prototype.bind</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @function bind(fn: Function, …): Function</span></div><div class="line"><span class="comment">// Returns a new function bound to the arguments passed, like </span></div><div class="line"><span class="comment">// [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).</span></div><div class="line"><span class="comment">// Has a `L.bind()` shortcut.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fn.bind) &#123;</div><div class="line">        <span class="keyword">return</span> fn.bind.apply(fn, slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> fn.apply(obj, args.length ? args.concat(slice.call(<span class="built_in">arguments</span>)) : <span class="built_in">arguments</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="temlape函数"><a href="#temlape函数" class="headerlink" title="temlape函数"></a>temlape函数</h4><p>leaflet的简单的模板函数， 支持将对象<code>{a: &#39;foo&#39;, b: &#39;bar&#39;}</code>的值填充至<code>&#39;Hello {a}, {b}&#39;</code>这样的模板字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> templateRe = <span class="regexp">/\&#123; *([\w_\-]+) *\&#125;/g</span>;</div><div class="line"></div><div class="line"><span class="comment">// @function template(str: String, data: Object): String</span></div><div class="line"><span class="comment">// Simple templating facility, accepts a template string of the form `'Hello &#123;a&#125;, &#123;b&#125;'`</span></div><div class="line"><span class="comment">// and a data object like `&#123;a: 'foo', b: 'bar'&#125;`, returns evaluated string</span></div><div class="line"><span class="comment">// `('Hello foo, bar')`. You can also specify functions instead of strings for</span></div><div class="line"><span class="comment">// data values — they will be evaluated passing `data` as an argument.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">template</span>(<span class="params">str, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.replace(templateRe, <span class="function"><span class="keyword">function</span> (<span class="params">str, key</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> value = data[key];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No value provided for variable '</span> + str);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>) &#123;</div><div class="line">            value = value(data);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="isArray函数"><a href="#isArray函数" class="headerlink" title="isArray函数"></a>isArray函数</h4><p>判断对象是否为数组的工具函数，与<code>Array.isArray</code>的功能兼容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @function isArray(obj): Boolean</span></div><div class="line"><span class="comment">// Compatibility polyfill for </span></div><div class="line"><span class="comment">//[Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)</span></div><div class="line"><span class="keyword">var</span> isArray = <span class="built_in">Array</span>.isArray || <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="indexOf函数"><a href="#indexOf函数" class="headerlink" title="indexOf函数"></a>indexOf函数</h4><p>用于匹配元素出现在数组中的位置，未匹配则返回-1,与<code>Array.indexOf</code>兼容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @function indexOf(array: Array, el: Object): Number</span></div><div class="line"><span class="comment">// Compatibility polyfill for </span></div><div class="line"><span class="comment">// [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">array, el</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (array[i] === el) &#123; <span class="keyword">return</span> i; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;extend函数&quot;&gt;&lt;a href=&quot;#extend函数&quot; class=&quot;headerlink&quot; title=&quot;extend函数&quot;&gt;&lt;/a&gt;extend函数&lt;/h4&gt;&lt;p&gt;合并函数，实现将第一个参数之后的所有对象合并至第一个参数对象中。&lt;/p&gt;
&lt;figure c
    
    </summary>
    
    
      <category term="leaflet util" scheme="https://zzhf.github.com/tags/leaflet-util/"/>
    
  </entry>
  
  <entry>
    <title>瀑布流布局实现方案</title>
    <link href="https://zzhf.github.com/2017/10/21/%E6%B8%A5%E5%85%B0%E7%BD%91%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <id>https://zzhf.github.com/2017/10/21/渥兰网页面布局实现方案/</id>
    <published>2017-10-21T07:24:10.000Z</published>
    <updated>2017-10-22T15:08:03.888Z</updated>
    
    <content type="html"><![CDATA[<p>周末空闲准备找部电影研究研究，最近《狙击精英：巅峰对决》挺火的，所以穷逼准备在网上搜索链接下载学习研究，无奈多次搜索未果，且大部分搜出来的链接都坏链。但是功夫不负有心人啊终于在<a href="http://www.oneland.org/" target="_blank" rel="external">渥兰网</a>这个重未听说过的资源网站上下到了自己想要的学习资料，在下载的过程中该网站的首页让我产生了浓厚的<code>F12</code>的兴趣。</p>
<a id="more"></a>
<h4 id="1-瀑布流自适应是如何实现的？"><a href="#1-瀑布流自适应是如何实现的？" class="headerlink" title="1.瀑布流自适应是如何实现的？"></a>1.瀑布流自适应是如何实现的？</h4><p>  当我第一次看见这种页面布局时，内心想的是肯定用的是column式布局，但是当我按下<code>F12</code>之后发现我的想法是完全错误，其布局实现方式主要是通过float使每一个海报项浮动起来，然后通过transform来控制每一个海报项位置,这样亦解决了float元素的一个填充对齐问题。但是问题来了transform的位移值是如何确定的？ </p>
<h6 id="1-1-如何确定位移值"><a href="#1-1-如何确定位移值" class="headerlink" title="1.1 如何确定位移值"></a>1.1 如何确定位移值</h6><p>  经过不断搜索该网站源代码发现他用的是一个叫<a href="https://github.com/metafizzy/isotope" target="_blank" rel="external">isotope</a>的插件。在github上翻看源码发现isotope是通过 原理实现的。</p>
<p>  <code>//TODO</code></p>
<h4 id="2-其无限加载是怎么实现的？"><a href="#2-其无限加载是怎么实现的？" class="headerlink" title="2.其无限加载是怎么实现的？"></a>2.其无限加载是怎么实现的？</h4><p>  在该网站中的无限加载是使用<a href="http://www.infinite-scroll.com" target="_blank" rel="external">infinitescroll</a>插件实现的，其实现的主要原理是</p>
<p>  <code>//TODO</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末空闲准备找部电影研究研究，最近《狙击精英：巅峰对决》挺火的，所以穷逼准备在网上搜索链接下载学习研究，无奈多次搜索未果，且大部分搜出来的链接都坏链。但是功夫不负有心人啊终于在&lt;a href=&quot;http://www.oneland.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;渥兰网&lt;/a&gt;这个重未听说过的资源网站上下到了自己想要的学习资料，在下载的过程中该网站的首页让我产生了浓厚的&lt;code&gt;F12&lt;/code&gt;的兴趣。&lt;/p&gt;
    
    </summary>
    
    
      <category term="瀑布流 infinitescroll imagesLoaded" scheme="https://zzhf.github.com/tags/%E7%80%91%E5%B8%83%E6%B5%81-infinitescroll-imagesLoaded/"/>
    
  </entry>
  
  <entry>
    <title>统计局行政区划数据抓取记录</title>
    <link href="https://zzhf.github.com/2017/10/18/%E7%BB%9F%E8%AE%A1%E5%B1%80%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%88%92%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96%E8%AE%B0%E5%BD%95/"/>
    <id>https://zzhf.github.com/2017/10/18/统计局行政区划数据抓取记录/</id>
    <published>2017-10-18T15:48:06.000Z</published>
    <updated>2017-10-18T15:59:45.488Z</updated>
    
    <content type="html"><![CDATA[<p>因为在最近的项目中需要全国的行政区划代码数据，所以特地用脚本抓取统计局的行政区划代码数据及行政区划统计数据，本blog主要记录抓取数据时遇到的一些问题及解决方案，涉及到的技术栈主要有node.js、 es6及es7的async await异步流程控制解决方案、 request请求工具库、 cheerio服务端dom解析库和mongoose存储MongoDB;</p>
<a id="more"></a>
<h4 id="1-服务端如何发HTTP请求？"><a href="#1-服务端如何发HTTP请求？" class="headerlink" title="1.服务端如何发HTTP请求？"></a>1.服务端如何发HTTP请求？</h4><h4 id="2-服务端请求的HTML页面如何解析？"><a href="#2-服务端请求的HTML页面如何解析？" class="headerlink" title="2.服务端请求的HTML页面如何解析？"></a>2.服务端请求的HTML页面如何解析？</h4><h4 id="3-服务端请求的HTML页面乱码怎么解决？"><a href="#3-服务端请求的HTML页面乱码怎么解决？" class="headerlink" title="3.服务端请求的HTML页面乱码怎么解决？"></a>3.服务端请求的HTML页面乱码怎么解决？</h4><h4 id="4-循环太多且全部是异步，如何进行流程控制？"><a href="#4-循环太多且全部是异步，如何进行流程控制？" class="headerlink" title="4.循环太多且全部是异步，如何进行流程控制？"></a>4.循环太多且全部是异步，如何进行流程控制？</h4><h4 id="5-数据如何入库？"><a href="#5-数据如何入库？" class="headerlink" title="5.数据如何入库？"></a>5.数据如何入库？</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为在最近的项目中需要全国的行政区划代码数据，所以特地用脚本抓取统计局的行政区划代码数据及行政区划统计数据，本blog主要记录抓取数据时遇到的一些问题及解决方案，涉及到的技术栈主要有node.js、 es6及es7的async await异步流程控制解决方案、 request请求工具库、 cheerio服务端dom解析库和mongoose存储MongoDB;&lt;/p&gt;
    
    </summary>
    
    
      <category term="node.js es6/7 request cheerio async/await mongoose" scheme="https://zzhf.github.com/tags/node-js-es6-7-request-cheerio-async-await-mongoose/"/>
    
  </entry>
  
  <entry>
    <title>ES6 暂时性死区（Temporal Dead Zone）</title>
    <link href="https://zzhf.github.com/2017/09/09/ES6%20Temporay%20Dead%20Zone/"/>
    <id>https://zzhf.github.com/2017/09/09/ES6 Temporay Dead Zone/</id>
    <published>2017-09-09T06:48:13.000Z</published>
    <updated>2017-09-11T15:11:13.057Z</updated>
    
    <content type="html"><![CDATA[<p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></div><div class="line">    <span class="keyword">let</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p>
<p>ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="comment">// TDZ开始</span></div><div class="line">    tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></div><div class="line">    <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></div><div class="line">    <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></div><div class="line"></div><div class="line">    tmp = <span class="number">123</span>;</div><div class="line">    <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError</span></div><div class="line"><span class="keyword">let</span> x;</div></pre></td></tr></table></figure>
<p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。</p>
<p>作为比较，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure>
<p>上面代码中，<code>undeclared_variable</code>是一个不存在的变量名，结果返回“<code>undefined</code>”。所以，在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p>
<p>有些“死区”比较隐蔽，不太容易发现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">bar(); <span class="comment">// 报错</span></div></pre></td></tr></table></figure>
<p>上面代码中，调用<code>bar</code>函数之所以报错（某些实现可能不报错），是因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于”死区“。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = <span class="number">2</span>, y = x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line">bar(); <span class="comment">// [2, 2]</span></div></pre></td></tr></table></figure>
<p>另外，下面的代码也会报错，与var的行为不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不报错</span></div><div class="line"><span class="keyword">var</span> x = x;</div><div class="line"></div><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">let</span> x = x;</div><div class="line"><span class="comment">// ReferenceError: x is not defined</span></div></pre></td></tr></table></figure>
<p>上面代码报错，也是因为暂时性死区。使用<code>let</code>声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量<code>x</code>的声明语句还没有执行完成前，就去取<code>x</code>的值，导致报错”<code>x</code>未定义“。</p>
<p>ES6 规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p>
<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只要块级作用域内存在&lt;code&gt;let&lt;/code&gt;命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://zzhf.github.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6 编码规范</title>
    <link href="https://zzhf.github.com/2017/09/08/ES6-Coding-Style/"/>
    <id>https://zzhf.github.com/2017/09/08/ES6-Coding-Style/</id>
    <published>2017-09-07T16:42:23.000Z</published>
    <updated>2017-09-10T17:22:39.855Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要规范ES6及传统的JavaScript语法结合的编写风格，便于写出合理的、易于阅读的和维护的代码，<br>下面主要的内容是参考了阮一峰老师的 <a href="http://es6.ruanyifeng.com/#docs/style" target="_blank" rel="external">ECMAScript 6 入门</a>;</p>
<a id="more"></a>
<h4 id="1-块级作用域"><a href="#1-块级作用域" class="headerlink" title="1.块级作用域"></a>1.块级作用域</h4><h5 id="1-1-let取代var"><a href="#1-1-let取代var" class="headerlink" title="1.1 let取代var"></a>1.1 <code>let</code>取代<code>var</code></h5><p>ES6提出了两个新的声明变量的命令： <code>let</code>和<code>const</code>。其中，<code>let</code>完全可以取代<code>var</code>，因为两者语义相同，而且<code>let</code>没有副作用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="string">'Hello'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码如果用<code>var</code>替代<code>let</code>，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，<code>var</code>命令做不到这一点。</p>
<p><code>var</code>命令存在变量提升效用，<code>let</code>命令没有这个问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(x); <span class="comment">//ReferenceError</span></div><div class="line">    <span class="keyword">let</span> x = <span class="string">'Hello'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。</p>
<blockquote>
<p>所以，建议不再使用var命令，而是使用let命令取代。</p>
</blockquote>
<h5 id="1-2-全局常量和线程安全"><a href="#1-2-全局常量和线程安全" class="headerlink" title="1.2 全局常量和线程安全"></a>1.2 全局常量和线程安全</h5><p>在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量。</p>
<p><code>const</code>优于<code>let</code>有几个原因。一个是<code>const</code>可以提醒阅读程序的人，这个变量不应该改变；另一个是<code>const</code>比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对<code>const</code>进行优化，所以多使用<code>const</code>，有利于提供程序的运行效率，也就是说<code>let</code>和<code>const</code>的本质区别，其实是编译器内部的处理不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//bad</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="comment">//good</span></div><div class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</div><div class="line"><span class="keyword">const</span> c = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="comment">//best</span></div><div class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div></pre></td></tr></table></figure>
<p><code>const</code>声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。</p>
<blockquote>
<p>所有的函数都应该设置为常量。</p>
</blockquote>
<p>长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时<code>let</code>表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p>
<h4 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h4><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//bad</span></div><div class="line"><span class="keyword">const</span> a = <span class="string">"foobar"</span>;</div><div class="line"><span class="keyword">const</span> b = <span class="string">'foo'</span> + a + <span class="string">'bar'</span>;</div><div class="line"></div><div class="line"><span class="comment">//acceptable</span></div><div class="line"><span class="keyword">const</span> c = <span class="string">`foobar`</span>;</div><div class="line"></div><div class="line"><span class="comment">//good</span></div><div class="line"><span class="keyword">const</span> a = <span class="string">'foobar'</span>;</div><div class="line"><span class="keyword">const</span> b = <span class="string">`foo<span class="subst">$&#123;a&#125;</span>bar`</span>;</div></pre></td></tr></table></figure>
<h4 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3.解构赋值"></a>3.解构赋值</h4><p>使用数组成员对变量赋值时，优先使用解构赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">//bad</span></div><div class="line"><span class="keyword">const</span> first = arr[<span class="number">0</span>];</div><div class="line"><span class="keyword">const</span> secod = arr[<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">//good</span></div><div class="line"><span class="keyword">const</span>[first, second] = arr;</div></pre></td></tr></table></figure>
<p>函数的参数如果是对象的成员，优先使用解构赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//bad </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> firstName = user.firstName;</div><div class="line">    <span class="keyword">const</span> lastName = user.lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> &#123; firstName, lastName &#125; = obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//best</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">&#123; firstName, lastName &#125;</span>) </span>&#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [left, right, top, bottom];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123; left, right, top, bottom &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123; left, right &#125; = processInput(input);</div></pre></td></tr></table></figure>
<h4 id="4-对象"><a href="#4-对象" class="headerlink" title="4.对象"></a>4.对象</h4><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//bad</span></div><div class="line"><span class="keyword">const</span> a = &#123;<span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2,&#125;;</div><div class="line"><span class="keyword">const</span> b = &#123;</div><div class="line">    k1: v1,</div><div class="line">    k2: v2</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//good</span></div><div class="line"><span class="keyword">const</span> a = &#123;<span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2&#125;;</div><div class="line"><span class="keyword">const</span> b = &#123;</div><div class="line">    k1: v1,</div><div class="line">    k2: v2,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//bad </span></div><div class="line"><span class="keyword">const</span> a = &#123;&#125;;</div><div class="line">a.x = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="comment">//if reshape unavoidable</span></div><div class="line"><span class="keyword">const</span> a = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.assign(a, &#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">//good</span></div><div class="line"><span class="keyword">const</span> a = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</div><div class="line">a.x = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">    id: <span class="number">5</span>,</div><div class="line">    name: <span class="string">'San Francisco'</span>,</div><div class="line">&#125;;</div><div class="line">obj[getKey(<span class="string">'enabled'</span>)] = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">    id: <span class="number">5</span>,</div><div class="line">    name: <span class="string">'San Francisco'</span>,</div><div class="line">    [getKey(<span class="string">'enabled'</span>)]: <span class="literal">true</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建<code>obj</code>的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。</p>
<p>另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ref = <span class="string">'some value'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> atom = &#123;</div><div class="line">    ref: ref,</div><div class="line"></div><div class="line">    value: <span class="number">1</span>,</div><div class="line"></div><div class="line">    addValue: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> atom.value + value;</div><div class="line">    &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> atom = &#123;</div><div class="line">    ref,</div><div class="line"></div><div class="line">    value: <span class="number">1</span>,</div><div class="line"></div><div class="line">    addValue(value) &#123;</div><div class="line">        <span class="keyword">return</span> atom.value + value;</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h4><p>使用扩展运算符<code>（...）</code>拷贝数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> len = items.length;</div><div class="line"><span class="keyword">const</span> itemsCopy = [];</div><div class="line"><span class="keyword">let</span> i;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">    itemsCopy[i] = items[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure>
<p>使用<code>Array.from</code>方法，将类似数组的对象转为数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.foo'</span>);</div><div class="line"><span class="keyword">const</span> nodes = <span class="built_in">Array</span>.from(foo);</div></pre></td></tr></table></figure>
<h4 id="6-函数"><a href="#6-函数" class="headerlink" title="6.函数"></a>6.函数</h4><p>立即执行函数可以写成箭头函数的形式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet.'</span>);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// best</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div></pre></td></tr></table></figure>
<p>箭头函数取代<code>Function.prototype.bind</code>，不应再用<code>self</code>/<code>_this</code>/<code>that</code>绑定 <code>this</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> self = <span class="keyword">this</span>;</div><div class="line"><span class="keyword">const</span> boundMethod = <span class="function"><span class="keyword">function</span>(<span class="params">...params</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> method.apply(self, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// acceptable</span></div><div class="line"><span class="keyword">const</span> boundMethod = method.bind(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="comment">// best</span></div><div class="line"><span class="keyword">const</span> boundMethod = <span class="function">(<span class="params">...params</span>) =&gt;</span> method.apply(<span class="keyword">this</span>, params);</div></pre></td></tr></table></figure></p>
<p>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。</p>
<p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, option = false </span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, &#123; option = false &#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不要在函数体内使用arguments变量，使用rest运算符（<code>...</code>）代替。因为<code>rest</code>运算符显式表明你想要获取参数，而且<code>arguments</code>是一个类似数组的对象，而<code>rest</code>运算符可以提供一个真正的数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">return</span> args.join(<span class="string">''</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> args.join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用默认值语法设置函数参数的默认值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</div><div class="line">    opts = opts || &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts = &#123;&#125;</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="7-Map"><a href="#7-Map" class="headerlink" title="7.Map"></a>7.Map</h4><p>注意区分<code>Object</code>和<code>Map</code>，只有模拟现实世界的实体对象时，才使用<code>Object</code>。如果只是需要<code>key: value</code>的数据结构，使用<code>Map</code>结构。因为<code>Map</code>有内建的遍历机制。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(arr);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</div><div class="line">   <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="8-Class"><a href="#8-Class" class="headerlink" title="8.Class"></a>8.Class</h4><p>总是用<code>Class</code>，取代需要<code>prototype</code>的操作。因为<code>Class</code>的写法更简洁，更易于理解。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params">contents = []</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>._queue = [...contents];</div><div class="line">&#125;</div><div class="line">Queue.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">  <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(contents = []) &#123;</div><div class="line">        <span class="keyword">this</span>._queue = [...contents];</div><div class="line">    &#125;</div><div class="line">    pop() &#123;</div><div class="line">    	<span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">    	<span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    	<span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用<code>extends</code>实现继承，因为这样更简单，不会有破坏<code>instanceof</code>运算的危险。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> inherits = <span class="built_in">require</span>(<span class="string">'inherits'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PeekableQueue</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">    Queue.apply(<span class="keyword">this</span>, contents);</div><div class="line">&#125;</div><div class="line">inherits(PeekableQueue, Queue);</div><div class="line">PeekableQueue.prototype.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekableQueue</span> <span class="keyword">extends</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">    peek() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="9-模块"><a href="#9-模块" class="headerlink" title="9.模块"></a>9.模块</h4><p>首先，<code>Module</code>语法是JavaScript模块的标准写法，坚持使用这种写法。使用<code>import</code>取代<code>require</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'moduleA'</span>);</div><div class="line"><span class="keyword">const</span> func1 = moduleA.func1;</div><div class="line"><span class="keyword">const</span> func2 = moduleA.func2;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">import</span> &#123; func1, func2 &#125; <span class="keyword">from</span> <span class="string">'moduleA'</span>;</div></pre></td></tr></table></figure></p>
<p>使用<code>export</code>取代<code>module.exports</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// commonJS的写法</span></div><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Breadcrumbs = React.createClass(&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> &lt;nav /&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = Breadcrumbs;</div><div class="line"></div><div class="line">// ES6的写法</div><div class="line">import React from 'react';</div><div class="line"></div><div class="line">class Breadcrumbs extends React.Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return &lt;nav /&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">export default Breadcrumbs;</div></pre></td></tr></table></figure></p>
<p>如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用<code>export default</code>，<code>export default</code>与普通的<code>export</code>不要同时使用。</p>
<p>不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（<code>export default</code>）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myObject <span class="keyword">from</span> <span class="string">'./importModule'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">import</span> myObject <span class="keyword">from</span> <span class="string">'./importModule'</span>;</div></pre></td></tr></table></figure></p>
<p>如果模块默认输出一个函数，函数名的首字母应该小写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeStyleGuide</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> makeStyleGuide;</div></pre></td></tr></table></figure></p>
<p>如果模块默认输出一个对象，对象名的首字母应该大写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> StyleGuide = &#123;</div><div class="line">    es6: &#123;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> StyleGuide;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要规范ES6及传统的JavaScript语法结合的编写风格，便于写出合理的、易于阅读的和维护的代码，&lt;br&gt;下面主要的内容是参考了阮一峰老师的 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/style&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMAScript 6 入门&lt;/a&gt;;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6 JavaScript" scheme="https://zzhf.github.com/tags/ES6-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>mongoose学习笔记</title>
    <link href="https://zzhf.github.com/2017/09/06/mongoose%20note/"/>
    <id>https://zzhf.github.com/2017/09/06/mongoose note/</id>
    <published>2017-09-06T14:14:51.000Z</published>
    <updated>2017-09-11T15:20:10.289Z</updated>
    
    <content type="html"><![CDATA[<p>最近在自己鼓捣<code>node.js</code>，尝试着使用<code>express</code> + <code>mongoose</code>搭建自己的web服务器，在这把<code>mongoose</code>的一些收获和知识点记录下来。<br>因为之前一直使用的是<code>java</code>操作<code>MongoDB</code>，对<code>java</code>实体类与<code>Map</code>对象的互转累觉不爱啊。<br><a id="more"></a></p>
<h4 id="Connect-to-MongoDB"><a href="#Connect-to-MongoDB" class="headerlink" title="Connect to MongoDB"></a>Connect to MongoDB</h4><figure class="highlight plain"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var mongoose = require(&apos;mongoose&apos;);</div><div class="line">//连接Mongo数据库</div><div class="line">mongoose.connect(&apos;mongodb://localhost/test&apos;); </div><div class="line"></div><div class="line">//监听Mongo首次连接事件</div><div class="line">db.once(&apos;open&apos; ,() =&gt; &#123; </div><div class="line">   console.log(&apos;连接数据库成功&apos;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//监听Mongo异常并重连</div><div class="line">db.on(&apos;error&apos;, function(error) &#123;</div><div class="line">    console.error(&apos;Error in MongoDb connection: &apos; + error);</div><div class="line">    mongoose.disconnect();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">db.on(&apos;close&apos;, function() &#123;</div><div class="line">       console.log(&apos;数据库断开，重新连接数据库&apos;);</div><div class="line">       mongoose.connect(config.url, &#123;server:&#123;auto_reconnect:true&#125;&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><p>首次接触<code>mongoose</code>的是<code>Schema</code>。<code>Schema</code>可以理解为表结构的定义，虽然<code>mongo</code>并没有表这个概念，类似与<code>java</code>中<code>pojo</code>实体类。<br>定义一个简单的Scheam</p>
<figure class="highlight plain"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var mongoose = require(&apos;mongoose&apos;);</div><div class="line">var Schema = mongoose.Schema;</div><div class="line"></div><div class="line">//定义对象blogSchema</div><div class="line">var blogSchema = new Schema(&#123;</div><div class="line">    title: String,</div><div class="line">    author: String,</div><div class="line">    body: String,</div><div class="line">    commets: [&#123;body: String, date: Date&#125;],</div><div class="line">    date: &#123;type: Date, defult: Date.now&#125;,</div><div class="line">    hidden: boolean,</div><div class="line">    meta: &#123;</div><div class="line">        votes: Number,</div><div class="line">        favs: Number</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//将blogSchema发布为model,并且指定collection名为blog_c;</div><div class="line">var blog = db.model(&apos;blog_c&apos;, blogSchema); </div></pre></td></tr></table></figure>
<p><code>Scheam</code>只是单纯的定义了mongoDB里面的document结构，通过Scheam可以定义字段的类型、唯一性、索引和验证；</p>
<h4 id="Schema可以定义的字段的类型有："><a href="#Schema可以定义的字段的类型有：" class="headerlink" title="Schema可以定义的字段的类型有："></a>Schema可以定义的字段的类型有：</h4><ul>
<li>String   </li>
<li>Number    </li>
<li>Date        </li>
<li>Buffer    </li>
<li>Boolean    </li>
<li>Mixed        </li>
<li>ObjectId    </li>
<li>Array        </li>
</ul>
<h4 id="一个包含所有类型Schema的实现"><a href="#一个包含所有类型Schema的实现" class="headerlink" title="一个包含所有类型Schema的实现"></a>一个包含所有类型<code>Schema</code>的实现</h4><figure class="highlight plain"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var mongoose = require(&apos;mongoose&apos;);</div><div class="line">var Schema = mongoose.Schema;</div><div class="line"></div><div class="line">var blogSchema = new Schema(&#123;</div><div class="line">    title: String,</div><div class="line">    author: String,</div><div class="line">    body: String,</div><div class="line">    commets: [&#123;body: String, date: Date&#125;],</div><div class="line">    date: &#123;type: Date, defult: Date.now&#125;,</div><div class="line">    hidden: boolean,</div><div class="line">    meta: &#123;</div><div class="line">	   votes: Number,</div><div class="line">	   favs: Number</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>通过执行<code>node index.js</code>就可以看见你的mongo库里面插入了一条包含各种数据类型的字段的Document记录；</p>
<h4 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h4><p>通过<code>node</code>+<code>mongoose</code>来操作<code>Mongo</code>确实比java来的方便的许多,比较JS原生支持json格式的数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在自己鼓捣&lt;code&gt;node.js&lt;/code&gt;，尝试着使用&lt;code&gt;express&lt;/code&gt; + &lt;code&gt;mongoose&lt;/code&gt;搭建自己的web服务器，在这把&lt;code&gt;mongoose&lt;/code&gt;的一些收获和知识点记录下来。&lt;br&gt;因为之前一直使用的是&lt;code&gt;java&lt;/code&gt;操作&lt;code&gt;MongoDB&lt;/code&gt;，对&lt;code&gt;java&lt;/code&gt;实体类与&lt;code&gt;Map&lt;/code&gt;对象的互转累觉不爱啊。&lt;br&gt;
    
    </summary>
    
    
      <category term="mongoose" scheme="https://zzhf.github.com/tags/mongoose/"/>
    
  </entry>
  
  <entry>
    <title>Start Blog Journey</title>
    <link href="https://zzhf.github.com/2017/09/02/Start-Blog-Journey/"/>
    <id>https://zzhf.github.com/2017/09/02/Start-Blog-Journey/</id>
    <published>2017-09-01T16:41:51.000Z</published>
    <updated>2017-09-10T17:09:10.609Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>你来到这里不是为了做选择，你早已选择了。你来到这里的目的，是为了了解你为什么这样选择。</p>
</blockquote>
<p>最近开始闲下来，兴趣之余决定开始搭建一个属于自己的博客。博客内容涉及的内容比较宽泛，涉及的话题主要有前端学习笔记及一些日常的牢骚，如果大家感兴趣的话可以访问我的 <a href="https://github.com/zzhf" target="_blank" rel="external">github</a> 关注。 如果有什么好的意见或建议可以在我的blog下提 <a href="https://github.com/zzhf/blog" target="_blank" rel="external">Issues</a> 。<br><a id="more"></a></p>
<h4 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h4><p>为了充分发扬拿来主义的精神，切忌重复造轮子。此博客系统是使用 <a href="https://hexo.io/" target="_blank" rel="external">hexo</a> 搭建，主题选用的是 <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="external">apollo</a>。<br>在众多hexo主题当中，这个仿VUE中文站的风格确实是及其养眼的，尤其是在移动设备上的展示效果，毕竟<a href="https://cn.vuejs.org/" target="_blank" rel="external">VUE中文站</a> 移动端效果还是让人眼前一亮的。</p>
<p>第一次写blog也不知道要说点啥，那就点到为止吧。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello World! Hello Blog!</div></pre></td></tr></table></figure>
<p><img src="https://avatars2.githubusercontent.com/u/23414235" alt="img"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;你来到这里不是为了做选择，你早已选择了。你来到这里的目的，是为了了解你为什么这样选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近开始闲下来，兴趣之余决定开始搭建一个属于自己的博客。博客内容涉及的内容比较宽泛，涉及的话题主要有前端学习笔记及一些日常的牢骚，如果大家感兴趣的话可以访问我的 &lt;a href=&quot;https://github.com/zzhf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt; 关注。 如果有什么好的意见或建议可以在我的blog下提 &lt;a href=&quot;https://github.com/zzhf/blog&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Issues&lt;/a&gt; 。&lt;br&gt;
    
    </summary>
    
    
      <category term="Misc" scheme="https://zzhf.github.com/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zzhf.github.com/2017/09/02/hello-world/"/>
    <id>https://zzhf.github.com/2017/09/02/hello-world/</id>
    <published>2017-09-01T16:27:01.496Z</published>
    <updated>2017-09-01T16:27:01.496Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
